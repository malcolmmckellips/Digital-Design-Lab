<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MM_Lab7_Course_Project: C:/Users/Freck/SimplicityStudio/v4_workspace/MM_Final_Lab7/src/Source_files/leuart.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MM_Lab7_Course_Project
   &#160;<span id="projectnumber">1</span>
   </div>
   <div id="projectbrief">Expansion of LEUART Driver to Support RX functionality</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('leuart_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">leuart.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains all the functions of the LEUART peripheral.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;em_gpio.h&quot;</code><br />
<code>#include &quot;em_cmu.h&quot;</code><br />
<code>#include &quot;leuart.h&quot;</code><br />
<code>#include &quot;scheduler.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a9699d72cf38f813d31fec5d2738fa885"><td class="memItemLeft" align="right" valign="top"><a id="a9699d72cf38f813d31fec5d2738fa885"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STARTFRAME_BIT</b>&#160;&#160;&#160;16</td></tr>
<tr class="separator:a9699d72cf38f813d31fec5d2738fa885"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa6692cf12b340a299c41a206068ee455"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leuart_8c.html#aa6692cf12b340a299c41a206068ee455">leuart_open</a> (LEUART_TypeDef *leuart, <a class="el" href="struct_l_e_u_a_r_t___o_p_e_n___s_t_r_u_c_t.html">LEUART_OPEN_STRUCT</a> *leuart_settings)</td></tr>
<tr class="memdesc:aa6692cf12b340a299c41a206068ee455"><td class="mdescLeft">&#160;</td><td class="mdescRight">LEUART driver.  <a href="leuart_8c.html#aa6692cf12b340a299c41a206068ee455">More...</a><br /></td></tr>
<tr class="separator:aa6692cf12b340a299c41a206068ee455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389a3178203c523630f1ab042cf623c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leuart_8c.html#a389a3178203c523630f1ab042cf623c3">leuart_start</a> (LEUART_TypeDef *leuart, char *string, uint32_t string_len)</td></tr>
<tr class="memdesc:a389a3178203c523630f1ab042cf623c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for starting the LEUART module for transmission.  <a href="leuart_8c.html#a389a3178203c523630f1ab042cf623c3">More...</a><br /></td></tr>
<tr class="separator:a389a3178203c523630f1ab042cf623c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6117796a042aa70da365f5c1da78c52c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leuart_8c.html#a6117796a042aa70da365f5c1da78c52c">leuart_send_char</a> (void)</td></tr>
<tr class="memdesc:a6117796a042aa70da365f5c1da78c52c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for servicing a txbl interrupt.  <a href="leuart_8c.html#a6117796a042aa70da365f5c1da78c52c">More...</a><br /></td></tr>
<tr class="separator:a6117796a042aa70da365f5c1da78c52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eac3408b2f7757445c7f52d41ed761c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leuart_8c.html#a6eac3408b2f7757445c7f52d41ed761c">leuart_finish</a> (void)</td></tr>
<tr class="memdesc:a6eac3408b2f7757445c7f52d41ed761c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for servicing a txc interrupt.  <a href="leuart_8c.html#a6eac3408b2f7757445c7f52d41ed761c">More...</a><br /></td></tr>
<tr class="separator:a6eac3408b2f7757445c7f52d41ed761c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d9593445d9cd26d0b9b0167c540722"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leuart_8c.html#a46d9593445d9cd26d0b9b0167c540722">leuart_startf</a> (void)</td></tr>
<tr class="memdesc:a46d9593445d9cd26d0b9b0167c540722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for handling STARTF interrupt.  <a href="leuart_8c.html#a46d9593445d9cd26d0b9b0167c540722">More...</a><br /></td></tr>
<tr class="separator:a46d9593445d9cd26d0b9b0167c540722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74564324f32156099a79cfc69583993"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leuart_8c.html#ab74564324f32156099a79cfc69583993">leuart_rxdatav</a> (void)</td></tr>
<tr class="memdesc:ab74564324f32156099a79cfc69583993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for handling RXDATAV interrupt.  <a href="leuart_8c.html#ab74564324f32156099a79cfc69583993">More...</a><br /></td></tr>
<tr class="separator:ab74564324f32156099a79cfc69583993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc922ef635a91c3a57cd7e47bfde6c7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leuart_8c.html#a1bc922ef635a91c3a57cd7e47bfde6c7">leuart_sigf</a> (void)</td></tr>
<tr class="memdesc:a1bc922ef635a91c3a57cd7e47bfde6c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for handling SIGF interrupt.  <a href="leuart_8c.html#a1bc922ef635a91c3a57cd7e47bfde6c7">More...</a><br /></td></tr>
<tr class="separator:a1bc922ef635a91c3a57cd7e47bfde6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6100ae82f114fbb9ff3c46bbb369c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leuart_8c.html#a1b6100ae82f114fbb9ff3c46bbb369c2">LEUART0_IRQHandler</a> (void)</td></tr>
<tr class="memdesc:a1b6100ae82f114fbb9ff3c46bbb369c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for handling IRQ0 Interrupts.  <a href="leuart_8c.html#a1b6100ae82f114fbb9ff3c46bbb369c2">More...</a><br /></td></tr>
<tr class="separator:a1b6100ae82f114fbb9ff3c46bbb369c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac375c07e8b8354d031bdd2ffdb993ac5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leuart_8c.html#ac375c07e8b8354d031bdd2ffdb993ac5">leuart_tx_busy</a> (LEUART_TypeDef *leuart)</td></tr>
<tr class="memdesc:ac375c07e8b8354d031bdd2ffdb993ac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for accessing the private leuart0_tx_busy variable from outside this module.  <a href="leuart_8c.html#ac375c07e8b8354d031bdd2ffdb993ac5">More...</a><br /></td></tr>
<tr class="separator:ac375c07e8b8354d031bdd2ffdb993ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213d0d2b818318edddd1ab869c324096"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leuart_8c.html#a213d0d2b818318edddd1ab869c324096">leuart_status</a> (LEUART_TypeDef *leuart)</td></tr>
<tr class="memdesc:a213d0d2b818318edddd1ab869c324096"><td class="mdescLeft">&#160;</td><td class="mdescRight">LEUART STATUS function returns the STATUS of the peripheral for the TDD test.  <a href="leuart_8c.html#a213d0d2b818318edddd1ab869c324096">More...</a><br /></td></tr>
<tr class="separator:a213d0d2b818318edddd1ab869c324096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7bfe6813f0c39daf30a00a95e870f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leuart_8c.html#a6a7bfe6813f0c39daf30a00a95e870f6">leuart_cmd_write</a> (LEUART_TypeDef *leuart, uint32_t cmd_update)</td></tr>
<tr class="memdesc:a6a7bfe6813f0c39daf30a00a95e870f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">LEUART CMD Write sends a command to the CMD register.  <a href="leuart_8c.html#a6a7bfe6813f0c39daf30a00a95e870f6">More...</a><br /></td></tr>
<tr class="separator:a6a7bfe6813f0c39daf30a00a95e870f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d2bedc4c3f0b3823ed8bd8a2f4f38a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leuart_8c.html#a76d2bedc4c3f0b3823ed8bd8a2f4f38a">leuart_if_reset</a> (LEUART_TypeDef *leuart)</td></tr>
<tr class="memdesc:a76d2bedc4c3f0b3823ed8bd8a2f4f38a"><td class="mdescLeft">&#160;</td><td class="mdescRight">LEUART IF Reset resets all interrupt flag bits that can be cleared through the Interrupt Flag Clear register.  <a href="leuart_8c.html#a76d2bedc4c3f0b3823ed8bd8a2f4f38a">More...</a><br /></td></tr>
<tr class="separator:a76d2bedc4c3f0b3823ed8bd8a2f4f38a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a12e8ba04667fd52e1fcfecdab277f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leuart_8c.html#a9a12e8ba04667fd52e1fcfecdab277f5">leuart_app_transmit_byte</a> (LEUART_TypeDef *leuart, uint8_t data_out)</td></tr>
<tr class="memdesc:a9a12e8ba04667fd52e1fcfecdab277f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">LEUART App Transmit Byte transmits a byte for the LEUART TDD test.  <a href="leuart_8c.html#a9a12e8ba04667fd52e1fcfecdab277f5">More...</a><br /></td></tr>
<tr class="separator:a9a12e8ba04667fd52e1fcfecdab277f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21909c4dd083a7b24960651acb1b421c"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leuart_8c.html#a21909c4dd083a7b24960651acb1b421c">leuart_app_receive_byte</a> (LEUART_TypeDef *leuart)</td></tr>
<tr class="memdesc:a21909c4dd083a7b24960651acb1b421c"><td class="mdescLeft">&#160;</td><td class="mdescRight">LEUART App Receive Byte polls a receive byte for the LEUART TDD test.  <a href="leuart_8c.html#a21909c4dd083a7b24960651acb1b421c">More...</a><br /></td></tr>
<tr class="separator:a21909c4dd083a7b24960651acb1b421c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9f7f443fa7bcee576971d61c7da9ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leuart_8c.html#a3f9f7f443fa7bcee576971d61c7da9ef">leuart_rx_test</a> (void)</td></tr>
<tr class="memdesc:a3f9f7f443fa7bcee576971d61c7da9ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test driven development test to confirm proper functionality of the receive function of LEUART module.  <a href="leuart_8c.html#a3f9f7f443fa7bcee576971d61c7da9ef">More...</a><br /></td></tr>
<tr class="separator:a3f9f7f443fa7bcee576971d61c7da9ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af28fe87a5c2e6381aa9595464ecf9abf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leuart_8c.html#af28fe87a5c2e6381aa9595464ecf9abf">get_leuart_rx_buffer</a> (char *destination)</td></tr>
<tr class="memdesc:af28fe87a5c2e6381aa9595464ecf9abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global function to export private leuart receive buffer state machine variable.  <a href="leuart_8c.html#af28fe87a5c2e6381aa9595464ecf9abf">More...</a><br /></td></tr>
<tr class="separator:af28fe87a5c2e6381aa9595464ecf9abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a881448b06b92f194080ed49319e9d161"><td class="memItemLeft" align="right" valign="top"><a id="a881448b06b92f194080ed49319e9d161"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>rx_done_evt</b></td></tr>
<tr class="separator:a881448b06b92f194080ed49319e9d161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa4290eee3a9186c8f46cf441bf32532"><td class="memItemLeft" align="right" valign="top"><a id="afa4290eee3a9186c8f46cf441bf32532"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>tx_done_evt</b></td></tr>
<tr class="separator:afa4290eee3a9186c8f46cf441bf32532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1685b1366bc3c6e0ca2ed2d106e3af"><td class="memItemLeft" align="right" valign="top"><a id="ade1685b1366bc3c6e0ca2ed2d106e3af"></a>
volatile bool&#160;</td><td class="memItemRight" valign="bottom"><b>leuart0_tx_busy</b></td></tr>
<tr class="separator:ade1685b1366bc3c6e0ca2ed2d106e3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f2bf1800e7a5e647f627576b6f7a9e"><td class="memItemLeft" align="right" valign="top"><a id="a28f2bf1800e7a5e647f627576b6f7a9e"></a>
volatile bool&#160;</td><td class="memItemRight" valign="bottom"><b>leuart0_rx_busy</b></td></tr>
<tr class="separator:a28f2bf1800e7a5e647f627576b6f7a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df9b789b39e17171e17d3287d9f0d9c"><td class="memItemLeft" align="right" valign="top"><a id="a5df9b789b39e17171e17d3287d9f0d9c"></a>
<a class="el" href="struct_l_e_u_a_r_t___p_a_y_l_o_a_d___s_t_r_u_c_t.html">LEUART_PAYLOAD_STRUCT</a>&#160;</td><td class="memItemRight" valign="bottom"><b>leuart_payload</b></td></tr>
<tr class="separator:a5df9b789b39e17171e17d3287d9f0d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c463d421ceeb31af826f4c1ccc3037"><td class="memItemLeft" align="right" valign="top"><a id="a49c463d421ceeb31af826f4c1ccc3037"></a>
<a class="el" href="struct_l_e_u_a_r_t___r_x___p_a_y_l_o_a_d___s_t_r_u_c_t.html">LEUART_RX_PAYLOAD_STRUCT</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rx_payload</b></td></tr>
<tr class="separator:a49c463d421ceeb31af826f4c1ccc3037"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains all the functions of the LEUART peripheral. </p>
<dl class="section author"><dt>Author</dt><dd>Malcolm McKellips </dd></dl>
<dl class="section date"><dt>Date</dt><dd>3/29/2020 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="af28fe87a5c2e6381aa9595464ecf9abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af28fe87a5c2e6381aa9595464ecf9abf">&#9670;&nbsp;</a></span>get_leuart_rx_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void get_leuart_rx_buffer </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>destination</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Global function to export private leuart receive buffer state machine variable. </p>
<p>The state machine variable rx_buffer will be copied into the destination specified by an input argument. This provides for proper modularity and encapsulation</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">destination</td><td>The string destination to copy the rx_buffer to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b6100ae82f114fbb9ff3c46bbb369c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b6100ae82f114fbb9ff3c46bbb369c2">&#9670;&nbsp;</a></span>LEUART0_IRQHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LEUART0_IRQHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for handling IRQ0 Interrupts. </p>
<p>The proper LEUART function for handling writes will be called if there is a TXBL interrupt. If a TXC interrupt is received, transmission is over and we can unblock sleep mode and schedule a tx_done_evt. Will also route the rx interrupts to their necessary handling functions. </p>

</div>
</div>
<a id="a21909c4dd083a7b24960651acb1b421c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21909c4dd083a7b24960651acb1b421c">&#9670;&nbsp;</a></span>leuart_app_receive_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t leuart_app_receive_byte </td>
          <td>(</td>
          <td class="paramtype">LEUART_TypeDef *&#160;</td>
          <td class="paramname"><em>leuart</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LEUART App Receive Byte polls a receive byte for the LEUART TDD test. </p>
<p>The BLE module will respond to AT commands if the BLE module is not connected to the phone app. To validate the minimal functionality of the LEUART peripheral, write and reads to the LEUART will be performed by polling and not interrupts.</p>
<dl class="section note"><dt>Note</dt><dd>In polling a receive byte, a while statement checking for the RXDATAV bit in the Interrupt Flag register is required before reading the RXDATA register.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">leuart</td><td>Defines the LEUART peripheral to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the byte read from the LEUART peripheral </dd></dl>

</div>
</div>
<a id="a9a12e8ba04667fd52e1fcfecdab277f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a12e8ba04667fd52e1fcfecdab277f5">&#9670;&nbsp;</a></span>leuart_app_transmit_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void leuart_app_transmit_byte </td>
          <td>(</td>
          <td class="paramtype">LEUART_TypeDef *&#160;</td>
          <td class="paramname"><em>leuart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LEUART App Transmit Byte transmits a byte for the LEUART TDD test. </p>
<p>The BLE module will respond to AT commands if the BLE module is not connected to the phone app. To validate the minimal functionality of the LEUART peripheral, write and reads to the LEUART will be performed by polling and not interrupts.</p>
<dl class="section note"><dt>Note</dt><dd>In polling a transmit byte, a while statement checking for the TXBL bit in the Interrupt Flag register is required before writing the TXDATA register.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*leuart</td><td>Defines the LEUART peripheral to access.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_out</td><td>Byte to be transmitted by the LEUART peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a7bfe6813f0c39daf30a00a95e870f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a7bfe6813f0c39daf30a00a95e870f6">&#9670;&nbsp;</a></span>leuart_cmd_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void leuart_cmd_write </td>
          <td>(</td>
          <td class="paramtype">LEUART_TypeDef *&#160;</td>
          <td class="paramname"><em>leuart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cmd_update</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LEUART CMD Write sends a command to the CMD register. </p>
<p>This function is used by the TDD test function to program the LEUART for the TDD tests.</p>
<dl class="section note"><dt>Note</dt><dd>Before exiting this function to update the CMD register, it must perform a SYNCBUSY while loop to ensure that the CMD has by synchronized to the lower frequency LEUART domain.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*leuart</td><td>Defines the LEUART peripheral to access.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd_update</td><td>The value to write into the CMD register </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6eac3408b2f7757445c7f52d41ed761c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eac3408b2f7757445c7f52d41ed761c">&#9670;&nbsp;</a></span>leuart_finish()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void leuart_finish </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function for servicing a txc interrupt. </p>
<p>If a TXC interrupt occurs while we are waiting for it, the process is finished and we can unblock the sleep mode and add the scheduled event that the transmission has finished. </p>

</div>
</div>
<a id="a76d2bedc4c3f0b3823ed8bd8a2f4f38a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76d2bedc4c3f0b3823ed8bd8a2f4f38a">&#9670;&nbsp;</a></span>leuart_if_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void leuart_if_reset </td>
          <td>(</td>
          <td class="paramtype">LEUART_TypeDef *&#160;</td>
          <td class="paramname"><em>leuart</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LEUART IF Reset resets all interrupt flag bits that can be cleared through the Interrupt Flag Clear register. </p>
<p>This function is used by the TDD test program to clear interrupts before the TDD tests and to reset the LEUART interrupts before the TDD exits</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*leuart</td><td>Defines the LEUART peripheral to access. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6692cf12b340a299c41a206068ee455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6692cf12b340a299c41a206068ee455">&#9670;&nbsp;</a></span>leuart_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void leuart_open </td>
          <td>(</td>
          <td class="paramtype">LEUART_TypeDef *&#160;</td>
          <td class="paramname"><em>leuart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_l_e_u_a_r_t___o_p_e_n___s_t_r_u_c_t.html">LEUART_OPEN_STRUCT</a> *&#160;</td>
          <td class="paramname"><em>leuart_settings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LEUART driver. </p>
<p>This module contains all the functions to support the driver's state machine to transmit a string of data across the LEUART bus. As of Lab 7 there are also functions to support receiving data over LEUART. There are additional functions to support the Test Driven Development test that is used to validate the basic set up of the LEUART peripheral. The TDD test for this class assumes that the LEUART is connected to the HM-18 BLE module. These TDD support functions could be used for any TDD test to validate the correct setup of the LEUART.</p>
<p>this function will open the LEUART peripheral</p>
<p>The function will open a leuart peripheral by configuring its transmission and receive details and routing via the leuart_settings struct. It will also enable necessary interrupts and perform checks to ensure that the peripheral has been opened correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">leuart</td><td>The leuart peripheral to be opened</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">leuart_settings</td><td>The configuration settings for the leuart being opened </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f9f7f443fa7bcee576971d61c7da9ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f9f7f443fa7bcee576971d61c7da9ef">&#9670;&nbsp;</a></span>leuart_rx_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void leuart_rx_test </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test driven development test to confirm proper functionality of the receive function of LEUART module. </p>
<p>Verifies the LEUART0 start and signal frame operation and proper initialization of the LEUART module for receives. The state machine for receiving a string message delimited with the start and singal frames will also be tested. To perform these tests, the leuart peripheral will be set to loopback mode for the duration of the test function so that all transmissions over leuart will be fed back into the receive of the leuart to test the receive functionality. The tests are as follows: Test 1: Confirm that the correct sleep mode has been blocked when rx is initialized Test 2: Verify that the start frame and the signal frames have been formatted properly as well as the block enable and the necessary interrupts. Test 3: Test that data is being blocked before the start frame is received Test 4: Test signal frame and the leuart receive state machine. Test 5: Test A second string transmission/receive to ensure that the state machine allows multiple receptions off of a signal initialization.</p>
<p>Test Escapes: -The test does not explicitly verify that the old rx buffer gets cleared when a new start frame is received (although several of the tests will likely test this) -The test does not explicitly verify state transitions. However, the overall function of the state machine is tested, so the functionality itself is verified. -The test does not account for errors in the leuart transmit process. If there are errors in tx, the rx test will not be air tight. -The test does not test performance in case of an rx_buffer overflow -The test does not test when multiple start frames or multiple sig frames are in a test string.</p>
<dl class="section note"><dt>Note</dt><dd>This test will assume already functional transmission over LEUART as it operates in loopback mode </dd></dl>

</div>
</div>
<a id="ab74564324f32156099a79cfc69583993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab74564324f32156099a79cfc69583993">&#9670;&nbsp;</a></span>leuart_rxdatav()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void leuart_rxdatav </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function for handling RXDATAV interrupt. </p>
<p>EFM_ASSERT unless we are in the receive state or finish state because all others are invalid states to receive the RXDATAV interrupt. If we are in the receive state, get the current receive data and put it in the receive payload buffer at the current index. Then, increment the index. If we get this interrupt while in the finishing state, we have received the sigframe. Add the sig frame to the receive string and append a null character at the end of our string. Set rx_busy to false, schedule an rx_done_evt and return to the idle state after re-setting the rx block. </p>

</div>
</div>
<a id="a6117796a042aa70da365f5c1da78c52c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6117796a042aa70da365f5c1da78c52c">&#9670;&nbsp;</a></span>leuart_send_char()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void leuart_send_char </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function for servicing a txbl interrupt. </p>
<p>If a TXBL interrupt occurs, and we have yet to transmit the entire string, stay in the current state but transmit the next character. If a TXBL interrupt occurs, and we have transmitted the entire string set the boolean state (tx_busy) to false, and disable txbl. We then now waiting for a TXC interrupt. </p>

</div>
</div>
<a id="a1bc922ef635a91c3a57cd7e47bfde6c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bc922ef635a91c3a57cd7e47bfde6c7">&#9670;&nbsp;</a></span>leuart_sigf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void leuart_sigf </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function for handling SIGF interrupt. </p>
<p>EFM_ASSERT if we are in an invalid state. Disregard a sig frame in the idle state because we should be blocking data in this state. If we are in the receive state, then a sigf signals we are done with a transmission so move to finish state. </p>

</div>
</div>
<a id="a389a3178203c523630f1ab042cf623c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a389a3178203c523630f1ab042cf623c3">&#9670;&nbsp;</a></span>leuart_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void leuart_start </td>
          <td>(</td>
          <td class="paramtype">LEUART_TypeDef *&#160;</td>
          <td class="paramname"><em>leuart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>string_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for starting the LEUART module for transmission. </p>
<p>The necessary sleep mode will be blocked and the boolean state of the state machine will be switched to leuart0_tx_busy = true to indicate that a write is in progress. Then the TXBL interrupt will be enabled, allowing an immediate TXBL interrupt and sending our state machine to the next state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">leuart</td><td>The leuart peripheral to start </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>The string data to send over LEUART </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">string_len</td><td>The length of the string being sent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46d9593445d9cd26d0b9b0167c540722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46d9593445d9cd26d0b9b0167c540722">&#9670;&nbsp;</a></span>leuart_startf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void leuart_startf </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function for handling STARTF interrupt. </p>
<p>Will enter an EFM assert if we receive a STARTF interrupt in any state except for idle or receive, because all others are invalid states. If we are in the idle state and we receive a STARTF character, we will initialize our string index to 0 and say that a receive is in process. We will change state to receive. If we are already in receive and we receive another start frame, start the transmission over (by setting the string index to 0). </p>

</div>
</div>
<a id="a213d0d2b818318edddd1ab869c324096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a213d0d2b818318edddd1ab869c324096">&#9670;&nbsp;</a></span>leuart_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t leuart_status </td>
          <td>(</td>
          <td class="paramtype">LEUART_TypeDef *&#160;</td>
          <td class="paramname"><em>leuart</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LEUART STATUS function returns the STATUS of the peripheral for the TDD test. </p>
<p>This function enables the LEUART STATUS register to be provided to a function outside this .c module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*leuart</td><td>Defines the LEUART peripheral to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the STATUS register value as an uint32_t value </dd></dl>

</div>
</div>
<a id="ac375c07e8b8354d031bdd2ffdb993ac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac375c07e8b8354d031bdd2ffdb993ac5">&#9670;&nbsp;</a></span>leuart_tx_busy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool leuart_tx_busy </td>
          <td>(</td>
          <td class="paramtype">LEUART_TypeDef *&#160;</td>
          <td class="paramname"><em>leuart</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for accessing the private leuart0_tx_busy variable from outside this module. </p>
<p>This function will return the private leuart0_tx_busy variable. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">leuart</td><td>The address of the leuart peripheral to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_b08c7e18a1c9321394998ac3912847c9.html">SimplicityStudio</a></li><li class="navelem"><a class="el" href="dir_14e13d991930c90ea61ca6a76579bd75.html">v4_workspace</a></li><li class="navelem"><a class="el" href="dir_b70859a890eb1a58616175aa55ff30ad.html">MM_Final_Lab7</a></li><li class="navelem"><a class="el" href="dir_6e18242f05b02c8ac5970e699f135d00.html">src</a></li><li class="navelem"><a class="el" href="dir_a3b83ee9fd9c09a1ab08584845a794e2.html">Source_files</a></li><li class="navelem"><a class="el" href="leuart_8c.html">leuart.c</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
